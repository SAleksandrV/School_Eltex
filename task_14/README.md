## task_14

### Программа fork_1
Cоздаёт один дочерний процесс, выводит pid родительского и дочернего процессов, а также статус завершения дочернего процесса.

### Программа fork_2
Cоздаёт два дочерних процесса (pid_01, pid_02), которые в свою очередь создают свои дочерние процессы первый процесс - один (pid_011), второй процесс - два (pid_021, pid_022).
Проверяем значение pid_01, если оно равно 0, значит мы находимся в дочернем процессе. Вызываем функцию first_child(). Если значение pid_01 больше 0, значит мы находимся в родительском процессе.
Аналогично создаём второй дочерний процесс путём вызова fork(). Если pid_02 больше 0, значит мы находимся в родительском процессе, выводим сообщение печатаем его идентификатор процесса.
Функция waitpid() используются для ожидания изменения состояния процесса-потомка вызвавшего процесса и получения информации о потомке, чьё состояние изменилось.
Если значения pid_02 и pid_01 меньше 0, выводим сообщения об ошибках при создании соответствующих дочерних процессов.
Родительский процесс ожидает завершения дочернего процесса и выводит статус его выхода. Очерёдность выводов pid процессов случайна!

Функция first_child() аналогично функция second_child():
    - Создаёт переменную pid_011 для хранения идентификатора процесса и переменную status для хранения статуса завершения дочернего процесса.
    - Выводим сообщение, что мы находимся в первом дочернем процессе и печатаем его идентификатор процесса (getpid() возвращает идентификатор вызвавшего процесса).
    - Вызываем функцию fork(), для создания дочернего процесса pid_01.
    - Проверяем значение pid_011, если оно равно 0 значит мы находимся в дочернем процессе. Выводим сообщение и завершаем процесс с кодом 11.
    - Если pid_011 больше 0, значит мы находимся в процессе pid_01, вызываем функцию wait() для ожидания завершения процесса pid_001, получаем и печатаем его статус.
