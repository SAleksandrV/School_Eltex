## task_11
Программа запускается с одним агрументом (текстовым файлом). Программа открывает данный файл для чтения и записи  (если его нет, создаёт) и дописывет в выбранный файл предложение "Training and work!", далее сохраняет изменения в файле и закрывает его.

Файловый дескриптор (file descriptor) - это целое число (int), соответствующее открытому файлу. В пределах одного процесса все дескрипторы уникальны (даже если они соответствуют одному и тому же файлу или устройству). В разных процессах дескрипторы могут совпадать или не совпадать - это не имеет никакого значения, поскольку у каждого процесса свой собственный набор открытых файлов.

### Системные вызовы:

    - open() объявлен в заголовочном файле fcntl.h. При открытии файла, позиция чтения-записи устанавливается в ноль. Адаптированные прототипы системного вызова open():
        * int open (const char * filename, int flags, mode_t mode);
        * int open (const char * filename, int flags);
    Первый аргумент - путь (абсолютный или относительный) и имя файла в файловой системе.
    Второй аргумент - режим открытия файла, представляющий собой один или несколько флагов открытия, объединённых оператором побитового ИЛИ (|). Наиболее часто используемые:
        * O_RDONLY - только чтение файла
        * O_WRONLY - только запись файла
        * O_RDWR - чтение и запись файла
        * O_CREAT - создать файл, если он не существует
        * O_TRUNC - если файл существует стереть его
        * O_APPEND - дописать в файл
        * O_EXCL - получение ошибки если файл существует, а мы пытаемся его создать (O_CREAT)
        * O_RDWR | O_CREAT - открыть файл в режиме чтения и записи, если файла нет он будет создан автоматически
    Третий аргумент - используется при создании функцией open() файла, ему определяются права доступа перечислением флагов объединённых оператором побитового ИЛИ (|) или восьмеричным числом. Флаги режима доступа реально объявлены в заголовочном файле bits/stat.h, но он не предназначен для включения в пользовательские программы, и вместо него мы должны включать файл sys/stat.h. Тип mode_t объявлен в заголовочном файле sys/types.h.:
        * S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH - пользователю, группе, всем разрешено чтение, запись, исполнение
        * 0777 - аналогичные права

    - read() объявлен в заголовочном файле unistd.h, позволяет читать данные из файла. Системный вызов читает данные в "сыром" виде, то есть как последовательность байт, без какой-либо интерпретации. Используя библиотечные механизмы, можно читать файл по-разному:
        * fscanf (filep, "%s", buffer);
        * fscanf (filep, "%d", number);
        * ssize_t read (int fd, void * buffer, size_t count); - адаптированный прототип read().
    Первый аргумент - файловый дескриптор.
    Второй аргумент - это указатель на область памяти, куда будут помещаться данные.
    Третий аргумент - количество байт, которые функция read() будет пытаться прочитать из файла. Возвращаемое значение - количество прочитанных байт, если чтение состоялось и -1, если произошла ошибка. Если read() возвращает значение меньше count, то это не символизирует об ошибке.

    - write() объявлен в заголовочном файле unistd.h, позволяет записывать count байтов из буфера buffer в файл с дескриптором fd, возвращая количество записанных байтов или -1 в случае ошибки. Прототип write() отличается от read() только спецификатором const во втором аргументе.
        * ssize_t write (int fd, const void * buffer, size_t count);
    
    - close() объявлен в заголовочном файле unistd.h закрывает файл. По завершении процесса все открытые файлы (кроме файлов с дескрипторами 0, 1 и 2) автоматически закрываются, если файлы не закрывать самостоятельно, то соответствующие дескрипторы не освобождаются, что может привести к превышению лимита открытых файлов. Адаптированный прототип:
        * int close (int fd);
    Единственный аргумент - это файловый дескриптор, возвращаемое значение - 0 в случае успеха, и -1 - в случае ошибки. Довольно часто close() вызывают без проверки возвращаемого значения, что является ошибкой, иногда закрытие файла бывает неудачным.
